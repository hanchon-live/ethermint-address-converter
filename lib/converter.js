var e=require("crypto-addr-codec"),r=require("bech32");const o={decoder:r=>{const o=e.stripHexPrefix(r);if(!e.isValidChecksumAddress(r,null)&&o!==o.toLowerCase()&&o!==o.toUpperCase())throw Error("Invalid address checksum");return Buffer.from(e.stripHexPrefix(r),"hex")},encoder:r=>e.toChecksumAddress(r.toString("hex"),null),name:"ETH"};function t(e){return o=>r.encode(e,r.toWords(o))}const d=(e,o)=>{return{decoder:(d=o,e=>{const{prefix:o,words:t}=r.decode(e);if(o!==d)throw Error("Unrecognised address format");return Buffer.from(r.fromWords(t))}),encoder:t(o),name:e};var d},s=d("ETHERMINT","ethm"),n=d("EVMOS","evmos"),c=d("REBUS","rebus");exports.ETH=o,exports.ETHERMINT=s,exports.EVMOS=n,exports.REBUS=c,exports.ethToEthermint=e=>{let r=o.decoder(e);return s.encoder(r)},exports.ethToEvmos=e=>{let r=o.decoder(e);return n.encoder(r)},exports.ethToRebus=e=>{let r=o.decoder(e);return c.encoder(r)},exports.ethermintToEth=e=>{let r=s.decoder(e);return o.encoder(r)},exports.evmosToEth=e=>{let r=n.decoder(e);return o.encoder(r)},exports.rebusToEth=e=>{let r=c.decoder(e);return o.encoder(r)};
//# sourceMappingURL=converter.js.map
